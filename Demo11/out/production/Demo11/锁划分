
1. api层面下划分
    synchronized
    lock

2. 锁的类型
    偏向锁，轻量级锁，重量级锁
    自旋锁 独占锁 共享锁
    公平锁 非公平锁

乐观锁 ：认为数据一般情况下并不会发生数据冲突。
        先尝试去获线程，发现获取不到，再去考虑如何去做。
        并不总是能能处理所有问题，所以会引入一定的系统复杂度。
    使用场景 ： 同一个时间点，经常只有一个线程对共享变量操作
    原理 ：直接对共享变量操作(线程安全) -> 加锁成功
                                       -> 加锁失败
           api调用方法的返回值 可以让我们知道是否加锁成功


悲观锁 ：假设总是最坏的情况，每次拿数据的时候都会认为别人会修改。
        总是需要竞争锁，进而导致发生线程切换，挂起其他线程，性能不高。
    使用场景 ：同一个时间点 经常有多个线程对共享变量操作
    原理 ：

比较 ：乐观锁是线程直接尝试修改的变量操作 (不会阻塞);
       悲观锁是线程先加锁，后修改变量操作

CAS ： Compare and swap 比较并交换
    java中的实现 ：java中 unsafe类（操作系统提供的接口）完成，本质是基于CPU提供接口保证线程安全修改变量
                  本质上基于CPU提供的对变量原子性线程的安全的修改操作
       CAS是一种乐观锁
       就是直接去操作
       内存中元数据 V = 1
       旧的预期值O  更新的新值N = 2
       旧的预期值O和内存中的数据V
        三步走 1. 先从主存中读取V的的值等于1 将预期的旧值O赋予1
               2. 将N的值2给直接向V赋值 但是同时比较 O与V是否相同
               3. O V 相同 则赋值成功 ;O V 不同 则赋值失败

CAS引发的ABA问题 ：加上版本号 每次修改版本号加一 交换的时候看版本号是否变化


自旋锁 ：
     无条件的自旋 ：抢锁失败 就死等
     有条件(自旋时间/次数)的自旋 ：如可中断自旋 (自旋时线程判断中断标志位后再执行)

自旋 + CAS 的适用场景 ：同一个时间点，常常只有一个线程操作.
           不适合场景 ：同一个时间点 常常很多线程操作
                       耗时较长 给了其他线程操作的机会

